// Evaluation Strategy

// Eventually, evaluation of a single lux file entry point (main.lux) should
// create the whole environment for the show, with Candela doing only the
// editing related work. However Candela will handle other tasks such as I/O,
// persistance, live update, and peripheries. Lux & Lumen are tightly coupled,
// Candela not so much.

// In the future, main.lux may be auto generated by candela, to handle the busy
// work of linking pieces together for the user, but this is a long way off.

// For now, we will start with a much simpler evaluation strategy, a single file
// will create an Lumen Environment that can be handed off and executed.

use std::fmt::Display;

use crate::ast::AstNode;
use lumen::{
    action::{Action, Apply, ApplyGroup},
    parameter::Param,
    timecode::time::Time,
    value::{generator::Static, Generator, Values},
    Environment, QueryBuilder,
};

type EvaluationResult = Result<(), EvaluationError>;

pub struct Evaluator {
    pub env: Environment,
    global_action: Action,
}

impl Evaluator {
    pub fn new(env: Environment) -> Self {
        Self {
            env,
            global_action: Action::new(),
        }
    }

    pub fn evaluate(&mut self, program: Vec<AstNode>) -> EvaluationResult {
        for node in program.iter() {
            self.evaluate_statement(node)?;
        }

        // NOTE: This is obviously temporary, but we just apply the global action at time 0
        self.env
            .fixtures
            .apply_action(&self.global_action, Time::at(0, 0, 0, 0));

        Ok(())
    }

    fn evaluate_statement(&mut self, node: &AstNode) -> EvaluationResult {
        let query = QueryBuilder::new().all().build();
        let mut global_apply_group = ApplyGroup::new(query);

        match node {
            AstNode::Apply(identifier, value) => {
                self.evaluate_apply(identifier, value, &mut global_apply_group)?;
            }
            AstNode::Select(_, _) => todo!(),
            _ => {
                return self.evaluation_error(format!("Expected a statement but got: {:?}", node));
            }
        }

        self.global_action.add_group(global_apply_group);

        Ok(())
    }

    fn evaluate_apply(
        &mut self,
        identifier: &AstNode,
        generator: &AstNode,
        apply_group: &mut ApplyGroup,
    ) -> EvaluationResult {
        let identifier = self.evaluate_identifier(identifier)?;
        let generator = self.evaluate_generator(generator)?;

        let apply = Apply::new(identifier, generator);

        apply_group.add_apply(apply);

        Ok(())
    }

    fn evaluate_identifier(&mut self, identifier: &AstNode) -> Result<Param, EvaluationError> {
        if let AstNode::Ident(identifier_string) = identifier {
            match Param::from_string(identifier_string) {
                Some(param) => Ok(param),
                None => self.evaluation_error(format!(
                    "Expected a valid parameter identifier but got: {}",
                    identifier_string
                )),
            }
        } else {
            self.evaluation_error(format!(
                "Expected a valid parameter identifier but got: {:?}",
                identifier
            ))
        }
    }

    fn evaluate_generator(
        &mut self,
        generator: &AstNode,
    ) -> Result<Box<dyn Generator>, EvaluationError> {
        let generator = match generator {
            AstNode::Numeric(number) => Box::new(Static::new(Values::make_literal(*number))),
            _ => {
                return self.evaluation_error(format!(
                    "Expected a valid generator but got: {:?}",
                    generator
                ))
            }
        };

        Ok(generator)
    }

    fn evaluation_error<T>(&self, text: String) -> Result<T, EvaluationError> {
        Err(EvaluationError(text))
    }
}

pub struct EvaluationError(String);
impl Display for EvaluationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
