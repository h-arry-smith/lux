* First milestone
#+begin_src
  [1] {
    intensity: 100
  }
#+end_src

should produce the AST
#+begin_src
  Selection
    Selector
      Value 1
    Block
      Apply
        Parameter "intensity"
        Value 100
#+end_src

* Time Thoughts
Types of time:
- Fade
  - Up Time
  - Down Time
- Delay
  - Up Time
  - Down Time
- Timecode
- Should have a shorcut to snap something,

Any time syntax needs to handle all of these. Some desks have a concept of follow, which is probably going to be better represented with another syntax when I flesh out cues and cue states.

#+begin_src
  // everything in block fades over 3 seconds
  @fade 3s {
  }

  // everything in block fades up in 3 seconds and down in 10 seconds
  @fade 3s/10s {
  }

  // everything in block doesn't happen for 3 seconds
  @delay 3s {
  }

  // everything in block does happen for 3 seconds
  @delay 3s/10s {
  }

  // it should be possible to define times in line
  [1] {
    intensity: 100 @fade 3s;
  }

  // snap something inside a time block
  @fade 3s {
    [1->12] { intensity: 100 @snap; }
  }
#+end_src

** Time Directives
#+begin_src
  @fade t
  @fade u/d
  @fade-up t
  @fade-down t

  @delay t
  @delay u/d
  @delay-up t
  @delay-down t

  @snap
#+end_src

** Implementation Notes
A fade/delay must know the current value, the future value, and it's time params - stored on the property of the fixture.

At some point it must handle the fact that fixture params will have min and maxs but I can worry about this in the future.

The interpreter must manage a stack of time information as blocks are entered and left, with any value creation refrencing the time information inline -> then to the parent

* Color and Position
** Position
You should be able to talk multi-paramter contexts using a variety syntaxes.

The first step in supporting this will be to support a tuple like structure that can both be named
and unnamed.

#+begin_src
  (10 10) // unnamed tuple
  (pan: 10, tilt: 20) // named tuple
#+end_src

Position is simpler in colour, that a position is always a combination of pan/tilt.
#+begin_src
  [101] {
    position: (-120.4 68.9); // A deliminator is needed to differntiate between a ValueRange and a multi parameter
  }

  // Should be the same as

  [101] {
    pan: -120.4;
    tilt: 68.9;
  }
#+end_src

When apply to any parameter, we need to be able to see if a paticular fixture has it defined as a multi-parameter.
This information comes from the fixture class building DSL. This seems overkill for position, where this is always the
same but lays the ground work for color nicely. In a sense, position becomes a virtual parameter.

When an unnamed tuple is passed to a group virtual parameter it is expanded into it's named form, which allows us to check that all relevant information has been provided.

#+begin_src ruby
  class MovingLight < Fixture
    param :intensity
    group :position do
      param :pan
      param :tilt
    end
  end
  #+end_src

  A virtual multi-paramter must always be provided the correct number of values in the tuple, and it's an error not to.
  There should be a magic symbol to mean current, or no value. It should support ValueRanges etc.

#+begin_src
  // Alternate between two options
  [101->106] {
    position: (10 20) (20 10);
  }

  // Accept ranges
  [101->106] {
    position: (10->50 50->10)
  }

  // This should be an error
  [101->106] {
    position: (10)
  }

  // But this isn't
  [101->106] {
    position: (10 _)
  }
#+end_src

** Color
In principle colour is a simple as the following:
#+begin_src ruby
  class MovingLight < Fixture
    param :intensity
    group :position do
      param :pan
      param :tilt
    end

    color :rgb # initial support :rgb :cmy
    # is really:
    # color_space :rgb
    # group :color
    #   param :red
    #   param :green
    #   param :blue
    # end
  end
#+end_src

And then we talk to the fixture using the tuple functionality already developed, basically giving the basics of this for free..

#+begin_src
  [101] {
    color: (100, 0, 0); // Full red for example
  }

  [102] {
    color: (red: 100, green: 100, blue: 0); // Yellow
  }

  [103] {
    color: (_, _, 25); // Partial application
  }
#+end_src

But what we really want to be able to do is translate between colourspaces, for example rgb vs rgba vs cmy

#+begin_src
  [101] {
    color: (cyan: 100, magenta: 0, yellow: 0) // This auto converts to RGB at application
  }
#+end_src

This is because a user should be able to use whatever colourspace they want and it should work.

The next step is that we want to be able to use syntax like the following, which is the beginning of allowing functions that return values.

#+begin_src
  [101] {
    color: rgb(100, 0, 0) rgb(0, 100, 0) // returns a call node with a function identifier and argument list
                                         // which interpreter runs returning a ValueTuple(red: 100, ...)
  }
#+end_src
* Palletes
It should obviously be possible to store information as referential data, like palletes in desk. To support this, we need to be able to execute a block inside a selection already, so this code should work
#+begin_src
  [101->106] {
    {
      position: (10, 10);
    }

    color: rgb(100, 0, 0);
  }
#+end_src

This should allow the following syntax to be applicable then, which is referred to as global application - literally inserting the block into the selection.

#+begin_src
  #front {
    position: (10, 10);
  }

  #red {
    color: rgb(100, 0, 0);
  }

  [101->106] {
    #front
    #red
  }
#+end_src

It should also be possible to do partial application, which will resolve just that paramater from the block, to support this we need to be able to ask a variable for only that parameter, or give context to the intepretation of a block that it is being filtered for only say :color, etc.

#+begin_src
  #red { color: rgb(100, 0, 0); }
  #green { color: rgb(0, 100, 0); }
  #blue { color: rgb(0, 0, 100); }

  [101->106] {
    color: #red #green #blue; // alternate between the three
  }
#+end_src

All palletes are declared globally, in the top level scope only.
* Live Coding Environment
It would be useful to start building a live coding environment for this project. For a couple of reasons:
- IDE environment to help with writing Lux code
- Visualisation pane (simple)
- Run code examples with live time
- Code pane is live evaluated, which allows changes to be seen life (restarting the cue time every time a valid state is found)
- Allow for shows to be built in file like structure...

* Grammar
#+begin_src
  program -> statement*
  statement -> selection | timer
  selection -> selector block
  selector -> "[" selection_expression "]"

  timer -> time+ block
  time -> "@" time_keyword NUMBER "s" time*
  time_keyword -> "fade" | "fade_up" | "fade_down" | "delay" | "delay_up" | "delay_down"

  expression_statement -> expression | statement
  
  block -> "{" expression_statement* "}"

  expression -> apply
  apply -> parameter arguments ";"
  parameter -> identifier ":" " "

  selection_expression -> value | range

  arguments -> argument argument*
  argument -> range | value | tuple

  tuple -> "("," argument ")"
  range -> NUMBER "->" NUMBER
  value -> NUMBER
  identifier -> ALPHANUMERIC+ ( "_" | ALPHANUMERIC )*
  
  NUMBER -> NUMERIC ( "." NUMERIC+ )?
  NEW_LINE -> "\n"
#+end_src
