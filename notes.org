* First milestone
#+begin_src
  [1] {
    intensity: 100
  }
#+end_src

should produce the AST
#+begin_src
  Selection
    Selector
      Value 1
    Block
      Apply
        Parameter "intensity"
        Value 100
#+end_src

* Time Thoughts
Types of time:
- Fade
  - Up Time
  - Down Time
- Delay
  - Up Time
  - Down Time
- Timecode
- Should have a shorcut to snap something,

Any time syntax needs to handle all of these. Some desks have a concept of follow, which is probably going to be better represented with another syntax when I flesh out cues and cue states.

#+begin_src
  // everything in block fades over 3 seconds
  @fade 3s {
  }

  // everything in block fades up in 3 seconds and down in 10 seconds
  @fade 3s/10s {
  }

  // everything in block doesn't happen for 3 seconds
  @delay 3s {
  }

  // everything in block does happen for 3 seconds
  @delay 3s/10s {
  }

  // it should be possible to define times in line
  [1] {
    intensity: 100 @fade 3s;
  }

  // snap something inside a time block
  @fade 3s {
    [1->12] { intensity: 100 @snap; }
  }
#+end_src

** Time Directives
#+begin_src
  @fade t
  @fade u/d
  @fade-up t
  @fade-down t

  @delay t
  @delay u/d
  @delay-up t
  @delay-down t

  @snap
#+end_src

** Implementation Notes
A fade/delay must know the current value, the future value, and it's time params - stored on the property of the fixture.

At some point it must handle the fact that fixture params will have min and maxs but I can worry about this in the future.

The interpreter must manage a stack of time information as blocks are entered and left, with any value creation refrencing the time information inline -> then to the parent

* Color and Position
You should be able to talk multi-paramter contexts using a variety syntaxes.

The first step in supporting this will be to support a tuple like structure that can both be named
and unnamed.

#+begin_src
  (10 10) // unnamed tuple
  (pan: 10, tilt: 20) // named tuple
#+end_src

Position is simpler in colour, that a position is always a combination of pan/tilt.
#+begin_src
  [101] {
    position: (-120.4 68.9); // A deliminator is needed to differntiate between a ValueRange and a multi parameter
  }

  // Should be the same as

  [101] {
    pan: -120.4;
    tilt: 68.9;
  }
#+end_src

When apply to any parameter, we need to be able to see if a paticular fixture has it defined as a multi-parameter.
This information comes from the fixture class building DSL. This seems overkill for position, where this is always the
same but lays the ground work for color nicely. In a sense, position becomes a virtual parameter.

When an unnamed tuple is passed to a group virtual parameter it is expanded into it's named form, which allows us to check that all relevant information has been provided.

#+begin_src ruby
  class MovingLight < Fixture
    param :intensity
    group :position do
      param :pan
      param :tilt
    end
  end
  #+end_src

  A virtual multi-paramter must always be provided the correct number of values in the tuple, and it's an error not to.
  There should be a magic symbol to mean current, or no value. It should support ValueRanges etc.

#+begin_src
  // Alternate between two options
  [101->106] {
    position: (10 20) (20 10);
  }

  // Accept ranges
  [101->106] {
    position: (10->50 50->10)
  }

  // This should be an error
  [101->106] {
    position: (10)
  }

  // But this isn't
  [101->106] {
    position: (10 _)
  }
#+end_src

* Live Coding Environment
It would be useful to start building a live coding environment for this project. For a couple of reasons:
- IDE environment to help with writing Lux code
- Visualisation pane (simple)
- Run code examples with live time
- Code pane is live evaluated, which allows changes to be seen life (restarting the cue time every time a valid state is found)
- Allow for shows to be built in file like structure...

* Grammar
#+begin_src
  program -> statement*
  statement -> selection | timer
  selection -> selector block
  selector -> "[" selection_expression "]"

  timer -> time+ block
  time -> "@" time_keyword NUMBER "s" time*
  time_keyword -> "fade" | "fade_up" | "fade_down" | "delay" | "delay_up" | "delay_down"

  expression_statement -> expression | statement
  
  block -> "{" expression_statement* "}"

  expression -> apply
  apply -> parameter arguments ";"
  parameter -> identifier ":" " "

  selection_expression -> value | range

  arguments -> argument argument*
  argument -> range | value | tuple

  tuple -> "(" (parameter? argument ",")* ")"
  range -> NUMBER "->" NUMBER
  value -> NUMBER
  identifier -> ALPHANUMERIC+ ( "_" | ALPHANUMERIC )*
  
  NUMBER -> NUMERIC ( "." NUMERIC+ )?
  NEW_LINE -> "\n"
#+end_src
