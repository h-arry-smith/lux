* First milestone
#+begin_src
  [1] {
    intensity: 100
  }
#+end_src

should produce the AST
#+begin_src
  Selection
    Selector
      Value 1
    Block
      Apply
        Parameter "intensity"
        Value 100
#+end_src

* Time Thoughts
Types of time:
- Fade
  - Up Time
  - Down Time
- Delay
  - Up Time
  - Down Time
- Timecode
- Should have a shorcut to snap something,

Any time syntax needs to handle all of these. Some desks have a concept of follow, which is probably going to be better represented with another syntax when I flesh out cues and cue states.

#+begin_src
  // everything in block fades over 3 seconds
  @fade 3s {
  }

  // everything in block fades up in 3 seconds and down in 10 seconds
  @fade 3s/10s {
  }

  // everything in block doesn't happen for 3 seconds
  @delay 3s {
  }

  // everything in block does happen for 3 seconds
  @delay 3s/10s {
  }

  // it should be possible to define times in line
  [1] {
    intensity: 100 @fade 3s;
  }

  // snap something inside a time block
  @fade 3s {
    [1->12] { intensity: 100 @snap; }
  }
#+end_src

** Time Directives
#+begin_src
  @fade t
  @fade u/d
  @fade-up t
  @fade-down t

  @delay t
  @delay u/d
  @delay-up t
  @delay-down t

  @snap
#+end_src

** Implementation Notes
A fade/delay must know the current value, the future value, and it's time params - stored on the property of the fixture.

At some point it must handle the fact that fixture params will have min and maxs but I can worry about this in the future.

The interpreter must manage a stack of time information as blocks are entered and left, with any value creation refrencing the time information inline -> then to the parent

* Color and Position
** Position
You should be able to talk multi-paramter contexts using a variety syntaxes.

The first step in supporting this will be to support a tuple like structure that can both be named
and unnamed.

#+begin_src
  (10 10) // unnamed tuple
  (pan: 10, tilt: 20) // named tuple
#+end_src

Position is simpler in colour, that a position is always a combination of pan/tilt.
#+begin_src
  [101] {
    position: (-120.4 68.9); // A deliminator is needed to differntiate between a ValueRange and a multi parameter
  }

  // Should be the same as

  [101] {
    pan: -120.4;
    tilt: 68.9;
  }
#+end_src

When apply to any parameter, we need to be able to see if a paticular fixture has it defined as a multi-parameter.
This information comes from the fixture class building DSL. This seems overkill for position, where this is always the
same but lays the ground work for color nicely. In a sense, position becomes a virtual parameter.

When an unnamed tuple is passed to a group virtual parameter it is expanded into it's named form, which allows us to check that all relevant information has been provided.

#+begin_src ruby
  class MovingLight < Fixture
    param :intensity
    group :position do
      param :pan
      param :tilt
    end
  end
  #+end_src

  A virtual multi-paramter must always be provided the correct number of values in the tuple, and it's an error not to.
  There should be a magic symbol to mean current, or no value. It should support ValueRanges etc.

#+begin_src
  // Alternate between two options
  [101->106] {
    position: (10 20) (20 10);
  }

  // Accept ranges
  [101->106] {
    position: (10->50 50->10)
  }

  // This should be an error
  [101->106] {
    position: (10)
  }

  // But this isn't
  [101->106] {
    position: (10 _)
  }
#+end_src

** Color
In principle colour is a simple as the following:
#+begin_src ruby
  class MovingLight < Fixture
    param :intensity
    group :position do
      param :pan
      param :tilt
    end

    color :rgb # initial support :rgb :cmy
    # is really:
    # color_space :rgb
    # group :color
    #   param :red
    #   param :green
    #   param :blue
    # end
  end
#+end_src

And then we talk to the fixture using the tuple functionality already developed, basically giving the basics of this for free..

#+begin_src
  [101] {
    color: (100, 0, 0); // Full red for example
  }

  [102] {
    color: (red: 100, green: 100, blue: 0); // Yellow
  }

  [103] {
    color: (_, _, 25); // Partial application
  }
#+end_src

But what we really want to be able to do is translate between colourspaces, for example rgb vs rgba vs cmy

#+begin_src
  [101] {
    color: (cyan: 100, magenta: 0, yellow: 0) // This auto converts to RGB at application
  }
#+end_src

This is because a user should be able to use whatever colourspace they want and it should work.

The next step is that we want to be able to use syntax like the following, which is the beginning of allowing functions that return values.

#+begin_src
  [101] {
    color: rgb(100, 0, 0) rgb(0, 100, 0) // returns a call node with a function identifier and argument list
                                         // which interpreter runs returning a ValueTuple(red: 100, ...)
  }
#+end_src
* Palletes
It should obviously be possible to store information as referential data, like palletes in desk. To support this, we need to be able to execute a block inside a selection already, so this code should work
#+begin_src
  [101->106] {
    {
      position: (10, 10);
    }

    color: rgb(100, 0, 0);
  }
#+end_src

This should allow the following syntax to be applicable then, which is referred to as global application - literally inserting the block into the selection.

#+begin_src
  #front {
    position: (10, 10);
  }

  #red {
    color: rgb(100, 0, 0);
  }

  [101->106] {
    #front
    #red
  }
#+end_src

It should also be possible to do partial application, which will resolve just that paramater from the block, to support this we need to be able to ask a variable for only that parameter, or give context to the intepretation of a block that it is being filtered for only say :color, etc.

#+begin_src
  #red { color: rgb(100, 0, 0); }
  #green { color: rgb(0, 100, 0); }
  #blue { color: rgb(0, 0, 100); }

  [101->106] {
    color: #red #green #blue; // alternate between the three
  }
#+end_src

All palletes are declared globally, in the top level scope only.
* LightingEngine World State -> Outputted DMX
Given the current lighting state, we should be able to ask every fixture for it's DMX Values and then apply them to a universe of data. The first step to doing this is to give the fixture DSL the information it needs

#+begin_src ruby
  class MovingLight < Fixture
    param :intensity, 1
    group :position do
      param :pan, 2, min: -270, max: 270, fine: true
      param :tilt, 4, min: -123, max: 123, fine: true
    end

    color :rgb, 5
  end
#+end_src

But it would also be nice, I suppose to omit those dmx offsets, if you define them in order it should be able to just tell what the correct offsets are.

When a fixture is instantiated it should be instantiated with a universe and a address.

The lighting engine takes the evaluated world state and runs it with a time variable that is always incrementing, for this first pass we will let it be static and ignore it. It works like this

1. Loop through all the fixtures in the world state
2. Ask each fixture for it's DMX Values
   1. The value array is a 0 instantiated array until the max offset
   2. The fixture asks each of its parameters to return a DMX value and inserts into the array
   3. The parameter instance provides it's numeric percentage based value to the parameter which calcs a 0-255 range for it (or two if the param is fine)
3. If the fixture universe exists in the universe index of the lighting engine insert the values
4. If not, create the required universe and then do it

** Implementation Strategy
- [x] Get the auto dmx offset working in the fixture DSL
- [x] Get this working for a simple dimmer rig, with debug output and the likes
- [x] Get this working for the current moving light
- [x] Add min, max and fine to the DSL
- [x] Give the lighting engine real time and eval delay and fades properly

* Show Files & Cue Stacks
** File Watching & Dev Console
Before any more work can continue the debug output needs to improve vastly and I need to be able to interact with a dev console outside of the main event loop.

This really only requires three seperate components
- A main view which shows the current state of the fixtures
- A REPL input that can send lines to the interpreter (interrupting the main loop)
- And a file watcher for the file passed to lux.

The main view can just show the fixture number and it's DMX values, debug output will still be in the main terminal window - which needs a lot of improving.

- [X] Improve Debug Output of World Lighting State
- [X] Implement a single file watcher that reloads the world state every time it changes
- [X] Seperate out core lux into it's own folder and restructure code running 
- [ ] Create a dev console which allows interaction with the lighting state while it's running.

** Basic Show Files
A Show file is a folder of a predefined structure. In the simple case before their is cue stacks this should only consist of a handful of files.
- Some sort of show information configuration file (.yml or similar)
- patch.lux - executed on show load to patch the show and any time it is changed. this creates a stored world in memory that is considered the base state - which will be useful for getting back to "the beginning" as it were
- main.lux - the main entry point to the show

This will serve for a first pass, though the show structure will evolve in all sorts of ways in the future, including when we add the ability to import other files. This allows colour definitions etc. to be in other files.

All shows are contained in a folder called shows, and the name of this is passed to the lux program.
The lux program starts an event loop, loading in the show.
It starts a watcher that will watch files for changes, and respond to them as needed - which for some of the default file structure might need special actions.

- [ ] Create a CLI command that creates a new show file and instantiates a basic structure
- [ ] Create a file watcher that watches for changes in all those files
- [ ] Load the test show file and execute main.lux

** Basic Folder/File Cue Lists
There is a folder called cues, which there are folders inside which are the cue lists, which can be called whatever you like - song names etc.
In each cuelist folder there are individual .lux files which are cues - it should be plenty fast enough to read in cues as they are needed. It may at some point be pertinent to cache file reads / AST's - for example cue stacks that loop there is no need to keep reloading the file and reinterpreting it.
It should be possible really to load a whole cue stack into memory at once, and discard of it when it's no longer being used but also seems complicated.

Cue lists are sorted alphabetical and numerically, but the nominal way is to do number order

You should be able to set times in the global scope of a cue, and each cue should always begin with a fresh root time context, of which the global statements mutate.

#+begin_src
  @fade 3s

  [101->105] {
    intensity: 100;
  }

  ...etc
#+end_src

There are some language command keywords that need to be implemented with the following semantics

#+begin_src
  load [cuelist] - set the main cuelist

  go - execute the next cue in the main cuelist
  go [cuelist] - execute the next cue in some other cuelist

  goto [cue] - go to a cue in the main cuelist, reexecuting all preceeding cues
  goto [cuelist] [cue] - go to a cue in the other cuelist, rexecuting all preceeding cues

  execute [cue] - run the code in the cue of the main cuelist without running the preceeding cues
  execute [cue] [cuelist] - run the code in a cuelist without running the preceeding cues
#+end_src

- [ ] Implement the global level time directives in main.lux
- [ ] Create a cuelist folder and cues insie of it
- [ ] Load a cuelist (by default for this purpose) and enter the first cue successfully
- [ ] Implement the load, go and goto, execute in it's basic form
- [ ] Implement the more complex versions, keeping track of each cuelist that's running and it's current cue position

* Live Coding Environment
It would be useful to start building a live coding environment for this project. For a couple of reasons:
- IDE environment to help with writing Lux code
- Visualisation pane (simple)
- Run code examples with live time
- Code pane is live evaluated, which allows changes to be seen life (restarting the cue time every time a valid state is found)
- Allow for shows to be built in file like structure...

* Grammar
#+begin_src
  program -> statement*
  statement -> selection | timer
  selection -> selector block
  selector -> "[" selection_expression "]"

  timer -> time+ block
  time -> "@" time_keyword NUMBER "s" time*
  time_keyword -> "fade" | "fade_up" | "fade_down" | "delay" | "delay_up" | "delay_down"

  expression_statement -> expression | statement
  
  block -> "{" expression_statement* "}"

  expression -> apply
  apply -> parameter arguments ";"
  parameter -> identifier ":" " "

  selection_expression -> value | range

  arguments -> argument argument*
  argument -> range | value | tuple

  tuple -> "("," argument ")"
  range -> NUMBER "->" NUMBER
  value -> NUMBER
  identifier -> ALPHANUMERIC+ ( "_" | ALPHANUMERIC )*
  
  NUMBER -> NUMERIC ( "." NUMERIC+ )?
  NEW_LINE -> "\n"
#+end_src

* Future Work To Do
- Palletes should have unit specific information, for example palletes for position are built up with speciifc information for each unit. This probably already works when doing general applicaiton, but will it for specific application?
- Complex query language features, by tags, by lighting position and more - the more powerful the better
- Group definitions
- Fixture patching and definition statements
- Fixture profiles
- Cues & Cue Stacks
- Faders & Executors
- Effects Standard Library
- DMX Value Literal
- Gobo & Color Wheel & Special Modes DSL w/ 'local' variables for assigning
- Proper Event Loop w edit UI, code running and executing and editing - aka a real usable experience
  fun idea: curses??
- You should be able to range @time directives
